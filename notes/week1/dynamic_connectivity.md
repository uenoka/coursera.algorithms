# dynamic connectivity

## 概要

SNS での友達やネットワーク内のコンピュータなど、実社会でもAとBが繋がる、繋がっているかを確認する、ということが多くある。  
問題を抽象化すると、次のようになる

- N個のオブジェクトがある
- Union コマンドで2つのオブジェクトをつなげる
- Find, connected クエリで2つのオブジェクトにつながりがあるかを確認する

ということをしたい。

これを行うためのデータ構造・アルゴリズムが Union find tree

## モデリング

### つながりがある、ということはどういうことか

P と Q が繋がっているということは次と同値

- 再帰性
  P は P に繋がっている
- 対称性
  P が Q に繋がっている場合、Q が P に繋がっている
- 推移性
  P が Q に繋がっていて、Q が R に繋がっている場合、P と R は繋がっている

ここの定義の1つ目については、プログラムで扱うときに便宜上そう定義しているように見えた。
というのも、具体的な世界でつながりがあるというと、たいていは「自己と他者がつながっている」というように使うと思うため。
プログラム上「PとPがつながっているか」というクエリに対して、繋がっていると返したいから感じた。（むしろ自分はこれに対して Exception 出したい気はする。）

## 実装

- Find Query では、2つのオブジェクトが同じグループにいるのかを確認する
- Union command では、2つのオブジェクトを含むグループを1つのグループに置き換える

### Union-find 型について

#### ゴール

効率的な、Union-findデータストラクチャを設計する

- オブジェクトの数Nは非常に大きくなる
- union, find 等の操作（M）も同様に非常に大きくなる
- union, find 等の操作は混合して実行される

#### API

```text
class UF
    UF() // Nこのオブジェクトで初期化する
    void union(p,q) // p, q をつなげる
    boolean connected(p,q) // p, q が同じコンポーネントかを確認する
    int find(p) // p のコンポーネントを確認する
    int count() // コンポーネントの数を確認する
```
